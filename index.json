
[{"content":"","date":"27 January 2026","externalUrl":null,"permalink":"/","section":"Malware Kindergarten","summary":"","title":"Malware Kindergarten","type":"page"},{"content":" ðŸ“¥ Download the PDF Your browser cannot display the PDF directly.\nClick here to download it. ","date":"27 January 2026","externalUrl":null,"permalink":"/cv/","section":"Malware Kindergarten","summary":"","title":"My Curriculum Vitae","type":"page"},{"content":"","date":"26 January 2026","externalUrl":null,"permalink":"/tags/c/","section":"Tags","summary":"","title":"C","type":"tags"},{"content":"","date":"26 January 2026","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 January 2026","externalUrl":null,"permalink":"/tags/linux-kernel/","section":"Tags","summary":"","title":"Linux Kernel","type":"tags"},{"content":"","date":"26 January 2026","externalUrl":null,"permalink":"/tags/low-level/","section":"Tags","summary":"","title":"Low Level","type":"tags"},{"content":"","date":"26 January 2026","externalUrl":null,"permalink":"/tags/malware-dev/","section":"Tags","summary":"","title":"Malware Dev","type":"tags"},{"content":"","date":"26 January 2026","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 January 2026","externalUrl":null,"permalink":"/categories/projects/","section":"Categories","summary":"","title":"Projects","type":"categories"},{"content":"In the world of cybersecurity, there is a distinct line between \u0026ldquo;User Space\u0026rdquo; (Ring 3) and \u0026ldquo;Kernel Space\u0026rdquo; (Ring 0). User space is where your browser, text editor, and shell live. It is safe, restricted, and monitored. Kernel space is the Wild West. It is where the hardware is controlled, where memory is managed, and crucially where the rules of reality for the operating system are defined.\nFor my latest project, I decided to cross that line. I developed a Linux Rootkit as a Loadable Kernel Module (LKM).\nDisclaimer: This project was developed strictly for educational purposes to understand OS internals and malware behavior. The techniques discussed here should never be used on systems without explicit authorization.\nThe Objective # The goal was to create a stealthy kernel module capable of:\nHiding itself from the list of loaded modules. Hiding files and directories from standard tools like ls. Hiding processes from tools like ps or top. Providing a Backdoor for instant root privilege escalation. Establishing covert communication channels. The Core Mechanism: Syscall Hooking # The Linux kernel interacts with user space programs via System Calls (syscalls). When you run ls, the program doesn\u0026rsquo;t actually look at the disk; it asks the kernel to do it via the sys_getdents64 syscall. When you run kill, it calls sys_kill.\nTo control the system, we don\u0026rsquo;t need to replace the tools; we just need to intercept these phone calls.\nThe Challenge: Control Register 0 (CR0) # In older versions of Linux, you could simply overwrite the sys_call_table. However, modern kernels have the Write Protect (WP) bit set in the CR0 register, preventing modification of the syscall table.\nWhile it is possible to disable this bit, a cleaner and more modern approach (and the one I utilized) involves using Ftrace (Function Tracer).\nThe Ftrace Solution # Ftrace is a debugging framework built into the kernel. It allows us to attach a callback to almost any function in the kernel. We can modify the instruction pointer (RIP) of a specific syscall to point to our malicious function instead of the real one.\n// Simplified Hooking Logic static struct ftrace_hook hooks[] = { HOOK(\u0026#34;sys_getdents64\u0026#34;, hook_getdents64, \u0026amp;orig_getdents64), HOOK(\u0026#34;sys_kill\u0026#34;, hook_kill, \u0026amp;orig_kill), }; Feature 1: The Art of Invisibility (Hiding Files) # How do you hide a file named malware_data? You hook sys_getdents64.\nThis syscall is responsible for listing the contents of a directory. It fills a buffer with linux_dirent64 structures. My hook works like a Man-in-the-Middle:\nIntercept: The user asks for a directory listing. Call Original: We call the real sys_getdents64 to get the actual data. Filter: We iterate through the returned buffer in memory. If we find a filename containing our magic prefix (e.g., hidden_), we memmove the rest of the buffer over it, effectively erasing it from existence. Return: We give the filtered buffer to the user. To the userâ€”and to the ls commandâ€”the file simply does not exist.\nFeature 2: The Magic Backdoor (Privilege Escalation) # A rootkit isn\u0026rsquo;t useful if you don\u0026rsquo;t have root access. To achieve persistence, I implemented a hook on the sys_kill syscall.\nNormally, kill is used to send signals to processes. I modified it to listen for a specific, unused signal (e.g., Signal 64).\nasmlinkage int hook_kill(pid_t pid, int sig) { if (sig == 64) { // The Magic Phrase was spoken! struct cred *new_creds = prepare_kernel_cred(NULL); // Create root creds commit_creds(new_creds); // Apply to current process return 0; } return orig_kill(pid, sig); // Otherwise, act normal } Now, any user on the system can simply type kill -64 1 in the terminal. Instead of sending a signal, the kernel grants that user\u0026rsquo;s shell uid=0 (Root) instantly. No passwords, no sudo logs.\nFeature 3: Secret Connections # The project also involved opening sockets directly from kernel space. This bypasses standard user-space firewalls that might be monitoring specific binaries. By utilizing kernel_sock_shutdown and call_usermodehelper, the rootkit can initiate a reverse shell to a remote listener, removing the process from user-space visibility. However, with the correct command, users can still see the connection to the remote server, but not the process itself.\nChallenges and Kernel Panics # Developing in Ring 0 is unforgiving. In C++, if you make a memory error, you get a \u0026ldquo;Segmentation Fault\u0026rdquo; and the program crashes. In Kernel C, if you dereference a null pointer or mess up a list pointer, the entire operating system crashes (Kernel Panic).\nDebugging involved setting up QEMU virtualization and analyzing crash dumps to ensure the hooks were stable and thread-safe.\nConclusion # This project was a fascinating journey into the depths of the Linux Operating System. It required a solid understanding of:\nC Programming (Memory management, pointers, structs). Assembly (Understanding registers and calling conventions). Operating System Architecture (VFS, Process Scheduling, Interrupts). By building the weapon, I learned exactly how to defend against it. Understanding how LKMs can be manipulated is crucial for forensic analysis and hardening Linux systems against advanced persistent threats.\n","date":"26 January 2026","externalUrl":null,"permalink":"/posts/rootkit/","section":"Posts","summary":"","title":"Ring 0 Operations: Building a Linux Rootkit from Scratch","type":"posts"},{"content":"","date":"26 January 2026","externalUrl":null,"permalink":"/tags/rootkit/","section":"Tags","summary":"","title":"Rootkit","type":"tags"},{"content":"","date":"26 January 2026","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Deep Dive: Process Injection via Code Cave Discovery on Linux # In the world of low-level systems programming and offensive security research, Process Injection is a surgical technique. While many developers are familiar with LD_PRELOAD or shared library injection, this project explores a more manual approach: finding a \u0026ldquo;Code Cave\u0026rdquo; and hijacking the instruction pointer () via the ptrace system call.\nThis article breaks down a C implementation of a Code Cave Injector designed to hijack a running process without causing a segmentation fault or crash.\nThe Architecture of the Injection # The objective of the code is to take control of a \u0026ldquo;victim\u0026rdquo; process, execute custom assembly, and then return control to the original execution flow. I have designed the logic to follow a strict four-stage workflow:\nAttachment: The code uses ptrace(PTRACE_ATTACH) to pause the target process and gain control over its registers. Reconnaissance: It parses /proc/[pid]/maps to find memory segments marked as executable (r-xp). Cave Hunting: It scans those segments for a \u0026ldquo;Code Cave\u0026rdquo;â€”a sequence of null bytes () large enough to hold the payload. Hijack: The code patches the payload with the target\u0026rsquo;s original , writes it into the cave, and redirects the process. 1. Defining the Payload (The \u0026ldquo;Guest\u0026rdquo;) # The payload is written in raw x86_64 assembly using an __asm__ block. To ensure the target process doesn\u0026rsquo;t crash, the assembly must save the CPU state.\n\u0026#34;push %rax; push %rdi; push %rsi...\u0026#34; // Save volatile registers // ... Syscall: write(1, msg, 32) ... \u0026#34;pop %rsi; pop %rdi; pop %rax...\u0026#34; // Restore registers \u0026#34;.byte 0x48, 0xb8\\n\u0026#34; // Opcode for MOV RAX, \u0026lt;immediate_64\u0026gt; \u0026#34;continuation: .quad 0x0\\n\u0026#34; // Placeholder for original RIP \u0026#34;jmp *%rax\\n\u0026#34; // Jump back to normal execution The use of .quad 0x0 is a critical design choice. It acts as a \u0026ldquo;hot patch\u0026rdquo; zone. The injector will find the bytes (the movabs instruction) and overwrite the subsequent 8 bytes with the address where the process was interrupted.\n2. Hunting for the Cave # A code cave typically exists because of memory page alignment. When a compiler generates a code section, it might only fill bytes of a -byte page. The remaining bytes are often filled with nulls and remain executable.\nThe find_code_cave function performs the following:\nIt opens /proc/[target_pid]/maps. It identifies regions with the \u0026lsquo;x\u0026rsquo; (executable) permission bit. It uses PTRACE_PEEKDATA to read the memory of the target 8 bytes at a time. It iterates through these bytes looking for a continuous stream of values that matches the payload_size. 3. The Patching Logic # Before writing to the target, the code must \u0026ldquo;contextualize\u0026rdquo; the payload. If the injector simply wrote the raw assembly, the process would have no way to return to its original task.\n// Search local_payload for the 0x48 0xb8 signature unsigned long return_addr_offset = 0; for(size_t i=0; i\u0026lt;payload_size-8; i++) { if(local_payload[i] == 0x48 \u0026amp;\u0026amp; local_payload[i+1] == 0xb8) { return_addr_offset = i + 2; break; } } // Overwrite the placeholder with the actual RIP of the victim *(unsigned long*)(local_payload + return_addr_offset) = regs-\u0026gt;rip; This logic ensures that the injected code acts as a \u0026ldquo;transparent wrapper.\u0026rdquo; I am essentially inserting a detour: the CPU goes to the cave, prints the message, and then jumps back to the exact instruction it was supposed to execute next.\n4. Modifying the Instruction Pointer # The final step is the actual redirection. I use PTRACE_SETREGS to update the target\u0026rsquo;s register state. By changing the to the address of the code cave, the next instruction the CPU fetches for that process will be the start of my payload.\nregs-\u0026gt;rip = cave_addr; if (ptrace(PTRACE_SETREGS, target, NULL, \u0026amp;regs) == -1) { perror(\u0026#34;ptrace setregs\u0026#34;); } Once ptrace(PTRACE_DETACH) is called, the kernel resumes the process. The victim process continues running, completely unaware that it just executed an external payload.\nTechnical Constraints and Stability # ASLR (Address Space Layout Randomization): This implementation bypasses ASLR because it queries the dynamic memory map of the process at runtime rather than relying on static offsets. PTRACE_SCOPE: On many modern Linux distributions, /proc/sys/kernel/yama/ptrace_scope is set to 1. This prevents the injector from attaching to processes that are not its children unless it is run with sudo. Memory Coherency: Since I am writing to an existing executable page, I don\u0026rsquo;t need to call mmap or mprotect, making the injection stealthier and less likely to trigger security alerts that monitor for RWX memory allocations. ","date":"18 January 2026","externalUrl":null,"permalink":"/posts/process_injector/","section":"Posts","summary":"","title":"Deep Dive: Process Injection via Code Cave Discovery on Linux","type":"posts"},{"content":"","date":"18 January 2026","externalUrl":null,"permalink":"/tags/elf/","section":"Tags","summary":"","title":"ELF","type":"tags"},{"content":"","date":"18 January 2026","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"Disclaimer: This tool is a Proof of Concept (PoC) for educational purposes only.\nUnderstanding how Linux executables work under the hood is the best way to understand system security. In this project, I built a \u0026ldquo;Code Cave Injector\u0026rdquo; â€” a tool that hides a payload inside an existing binary without changing its file size.\nHere is a breakdown of how my Infektor tool works, referencing the source code.\nThe Concept: What is a \u0026ldquo;Code Cave\u0026rdquo;? # When a compiler (like GCC) builds a program, it organizes the code into Segments. To optimize memory access, these segments are aligned to Page Boundaries (usually 4096 bytes / 0x1000).\nBecause code rarely fits exactly into these 4096-byte blocks, there is often empty space (padding) filled with zeros at the end of the executable segment. This gap is called a Code Cave.\nVisualizing the gaps between segments in an ELF file.\nMy tool finds this gap and inserts shellcode into it.\nKey Implementation Details # The injector performs three main tasks:\nMap the target binary into memory. Find a suitable gap (Code Cave) in the executable segment. Inject the payload and hijack the Entry Point. 1. Memory Mapping (mmap) # Instead of using standard read/write calls, I used mmap. This maps the file directly into the program\u0026rsquo;s virtual memory space. Any change I make to the memory array file[] is written directly to the disk thanks to the MAP_SHARED flag.\nunsigned char *file = mmap( NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, // Writes sync back to the file fd, 0 ); 2.The Safety Check (calculate_gap) # This is the most critical part of the code. If we blindly inject code, we might overwrite the next segment (like .data or .rodata), crashing the program.\nI implemented a function calculate_gap that looks at the PT_LOAD segment headers to measure exactly how much space exists before the next segment starts.\nsize_t calculate_gap(Elf64_Phdr *target, Elf64_Phdr *all_hdrs, int count, size_t file_size) { Elf64_Off target_end = target-\u0026gt;p_offset + target-\u0026gt;p_filesz; Elf64_Off nearest_next_start = file_size; // Scan all headers to find the one that starts immediately after our target for (int i = 0; i \u0026lt; count; i++) { Elf64_Off current_start = all_hdrs[i].p_offset; if (current_start \u0026gt;= target_end) { if (current_start \u0026lt; nearest_next_start) { nearest_next_start = current_start; } } } return nearest_next_start - target_end; } If size_payload \u0026gt; available_gap, the tool aborts with a CRITICAL ERROR. This ensures reliability.\n3. Hijacking Execution (infection) # Once the space is confirmed, the injection happens.\nCopy Payload: I copy the shellcode to the end of the text segment.\nPatch Return Address: My payload needs to jump back to the original program so the user doesn\u0026rsquo;t notice anything. I calculate jt_offset and patch the jump_target variable inside the shellcode dynamically.\nUpdate Entry Point: Finally, I modify the ELF Header (e_entry) to point to my new code location (payload_va).\nint infection(int fd, Elf64_Ehdr *ehdr, Elf64_Phdr *phdr, unsigned char *file) { // ... logic to calculate offsets ... // Patch the payload with the original entry point memcpy(payload_dst + jt_offset, \u0026amp;original_entry, sizeof(Elf64_Addr)); // Hijack the binary entry point ehdr-\u0026gt;e_entry = payload_va; // Officially extend the segment size to include the payload phdr-\u0026gt;p_filesz += size; phdr-\u0026gt;p_memsz += size; return 0; } Linking C and Assembly # One interesting challenge was linking the C injector with the Assembly payload. I used extern symbols to access labels defined in the .s file directly from C.\nextern unsigned char payload_start; extern unsigned long jump_target; This allows the C code to measure the payload size dynamically and know exactly where to patch the jump addresses.\nConclusion # This project was a deep dive into the ELF file format. By manipulating Elf64_Phdr structures directly, I learned how the OS loader parses binaries. The result is a stealthy persistence mechanism that leaves the file size unchanged on the disk (ls -l shows no difference!).\n","date":"13 January 2026","externalUrl":null,"permalink":"/posts/elf-infektor/","section":"Posts","summary":"","title":"Deep Dive: Writing an ELF Code Cave Infector in C","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]